<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DFITIME</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  background: black;
  font-family: system-ui, sans-serif;
  color: #caa6ff;
}

/* ---- IMPERFECT PURPLE BRICK WALL ---- */
#brickWall {
  position: fixed;
  inset: 0;
  z-index: 0;

  background-color: #0a0614;

  background-image:
    /* vertical cracks layer A */
    repeating-linear-gradient(
      90deg,
      rgba(200,150,255,0.28) 0px,
      rgba(200,150,255,0.28) 2px,
      transparent 2px,
      transparent 68px
    ),

    /* vertical cracks layer B (offset + different width) */
    repeating-linear-gradient(
      90deg,
      rgba(200,150,255,0.22) 0px,
      rgba(200,150,255,0.22) 1.5px,
      transparent 1.5px,
      transparent 74px
    ),

    /* horizontal mortar */
    repeating-linear-gradient(
      0deg,
      rgba(200,150,255,0.22) 0px,
      rgba(200,150,255,0.22) 2px,
      transparent 2px,
      transparent 36px
    );

  background-size:
    72px 72px,
    86px 72px,
    100% 36px;

  background-position:
    0 0,
    36px 18px,
    0 0;
}

/* ---- NEON STACK ---- */
#neonWrap {
  position: absolute;
  top: 10%;
  width: 100%;
  text-align: center;
  pointer-events: none;
  z-index: 2;
}

.neonLine {
  font-weight: 900;
  letter-spacing: 0.22em;
  line-height: 1.05;
}

#neonDFI {
  font-size: min(18vw, 220px);
}

#neonTIME {
  font-size: min(14vw, 160px);
  margin-top: 8px;
}

.neonLine span {
  display: inline-block;
  color: #d8c6ff;
  text-shadow:
    0 0 4px rgba(210,190,255,0.9),
    0 0 12px rgba(160,120,220,0.6),
    0 0 28px rgba(130,90,200,0.45),
    0 0 70px rgba(90,50,160,0.35);
  animation: breathe 4.5s ease-in-out infinite;
}

/* ---- CONTROLS ---- */
#controls {
  position: absolute;
  top: 38%;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 18px;
  z-index: 3;
}

button {
  background: rgba(40,10,80,0.65);
  color: #e0c8ff;
  border: 2px solid rgba(160,120,255,0.6);
  padding: 18px 28px;
  font-size: 22px;
  letter-spacing: 0.15em;
  cursor: pointer;
  backdrop-filter: blur(6px);
}

button.active {
  background: rgba(190,150,255,0.95);
  color: black;
}

button:hover {
  background: rgba(160,120,255,0.85);
  color: black;
}

/* ---- ANIM ---- */
@keyframes breathe {
  0% { opacity: 0.85; }
  50% { opacity: 0.98; }
  100% { opacity: 0.85; }
}

/* ---- CANVAS ---- */
canvas {
  display: block;
  touch-action: none;
  position: relative;
  z-index: 1;
}
</style>
</head>

<body>

<div id="brickWall"></div>

<div id="neonWrap">
  <div id="neonDFI" class="neonLine">
    <span>D</span><span>F</span><span>I</span>
  </div>
  <div id="neonTIME" class="neonLine">
    <span>T</span><span>I</span><span>M</span><span>E</span>
  </div>
</div>

<div id="controls">
  <button class="active" onclick="setIntervalMode(1,this)">1&nbsp;SEC</button>
  <button onclick="setIntervalMode(60,this)">1&nbsp;MIN</button>
  <button onclick="setIntervalMode(3600,this)">1&nbsp;HOUR</button>
  <button onclick="setIntervalMode(86400,this)">1&nbsp;DAY</button>
</div>

<canvas id="chart"></canvas>

<script>
document.querySelectorAll(".neonLine span").forEach(letter => {
  setInterval(() => {
    if (Math.random() < 0.08) {
      letter.style.opacity = "0.35";
      setTimeout(() => letter.style.opacity = "0.95", 40);
    }
  }, 180 + Math.random() * 400);
});

const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const KEY = "clockchart_start";
let start = localStorage.getItem(KEY);
if (!start) {
  start = Date.now();
  localStorage.setItem(KEY, start);
} else {
  start = Number(start);
}

let INTERVAL_SEC = 1;

const CHART_WIDTH = 800;
const CHART_HEIGHT = 300;
const CANDLE_WIDTH = 6;
const CANDLE_GAP = 4;
const STEP = CANDLE_WIDTH + CANDLE_GAP;

let scrollOffset = 0;
let isHolding = false;
let lastX = 0;
let px = canvas.width / 2;
let py = canvas.height / 2;

canvas.addEventListener("pointerdown", e => {
  canvas.setPointerCapture(e.pointerId);
  isHolding = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if (!isHolding) return;
  scrollOffset += e.clientX - lastX;
  lastX = e.clientX;
  px = e.clientX;
  py = e.clientY;
});

canvas.addEventListener("pointerup", e => {
  isHolding = false;
  canvas.releasePointerCapture(e.pointerId);
});

function setIntervalMode(sec, btn) {
  INTERVAL_SEC = sec;
  document.querySelectorAll("button").forEach(b => b.classList.remove("active"));
  btn.classList.add("active");
}

function draw() {
  const ox = (canvas.width - CHART_WIDTH) / 2;
  const oy = (canvas.height - CHART_HEIGHT) / 2 + 260;

  ctx.fillStyle = "rgba(0,0,0,0.08)";
  ctx.fillRect(ox - 40, oy - 40, CHART_WIDTH + 80, CHART_HEIGHT + 80);

  const elapsedSec = Math.floor((Date.now() - start) / 1000);
  const candles = Math.floor(elapsedSec / INTERVAL_SEC) + 1;
  const maxVisible = Math.ceil(CHART_WIDTH / STEP) + 2;
  const startIndex = Math.max(0, candles - maxVisible);

  for (let i = startIndex; i < candles; i++) {
    const x = ox + (i - startIndex) * STEP + scrollOffset;
    if (x < ox - STEP || x > ox + CHART_WIDTH + STEP) continue;

    const h = ((i + 1) / candles) * CHART_HEIGHT;
    ctx.fillStyle = (i % 2 === 0) ? "#9a6bff" : "#4b257a";
    ctx.fillRect(x, oy + CHART_HEIGHT - h, CANDLE_WIDTH, Math.max(h, 6));
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
