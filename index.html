<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ClockChart</title>

<style>
  body {
    margin: 0;
    background: black;
    font-family: system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    color: #caa6ff;
  }

  canvas {
    border: 1px solid #2a0044;
    touch-action: none; /* important for swipe */
  }

  #count {
    margin-top: 8px;
    font-size: 14px;
  }
</style>
</head>
<body>

<canvas id="chart" width="800" height="300"></canvas>
<div id="count">0</div>

<script>
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");
const countEl = document.getElementById("count");

// --- time persistence ---
const KEY = "clockchart_start";
let start = localStorage.getItem(KEY);
if (!start) {
  start = Date.now();
  localStorage.setItem(KEY, start);
} else {
  start = Number(start);
}

// --- config ---
const INTERVAL_SEC = 1;
const CANDLE_WIDTH = 6;
const CANDLE_GAP = 4; // âœ¨ spacing
const STEP = CANDLE_WIDTH + CANDLE_GAP;

// --- swipe state ---
let scrollOffset = 0;
let isDragging = false;
let lastX = 0;
let trailAlpha = 0;

// --- audio (soft chime) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playChime(pitch = 440) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = "sine";
  o.frequency.value = pitch;

  g.gain.value = 0.0001;
  g.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.3);

  o.connect(g).connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + 0.31);
}

// --- swipe handlers ---
canvas.addEventListener("pointerdown", e => {
  isDragging = true;
  lastX = e.clientX;
  trailAlpha = 1;
});

canvas.addEventListener("pointermove", e => {
  if (!isDragging) return;
  const dx = e.clientX - lastX;
  scrollOffset += dx;
  lastX = e.clientX;

  playChime(300 + Math.abs(dx) * 5);
  trailAlpha = 1;
});

canvas.addEventListener("pointerup", () => isDragging = false);
canvas.addEventListener("pointerleave", () => isDragging = false);

// --- draw loop ---
function draw() {
  // fade trail
  ctx.fillStyle = `rgba(0,0,0,0.25)`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const elapsedSec = Math.floor((Date.now() - start) / 1000);
  const candles = Math.floor(elapsedSec / INTERVAL_SEC) + 1;
  countEl.textContent = `${candles} seconds`;

  const maxVisible = Math.ceil(canvas.width / STEP) + 2;
  const startIndex = Math.max(0, candles - maxVisible);

  for (let i = startIndex; i < candles; i++) {
    const x = (i - startIndex) * STEP + scrollOffset;
    if (x < -STEP || x > canvas.width + STEP) continue;

    const h = ((i + 1) / candles) * canvas.height;

    // alternating color rhythm
    ctx.fillStyle = (i % 2 === 0) ? "#b084ff" : "#5a2bbf";
    ctx.fillRect(x, canvas.height - h, CANDLE_WIDTH, Math.max(h, 6));
  }

  // trail glow overlay
  if (trailAlpha > 0) {
    ctx.fillStyle = `rgba(176,132,255,${trailAlpha * 0.08})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    trailAlpha *= 0.9;
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
