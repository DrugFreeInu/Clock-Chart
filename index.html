<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ClockChart</title>

<style>
  body {
    margin: 0;
    background: black;
    font-family: system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    color: #caa6ff;
  }

  canvas {
    border: 1px solid #2a0044;
    touch-action: none;
  }

  #count {
    margin-top: 8px;
    font-size: 14px;
  }
</style>
</head>
<body>

<canvas id="chart" width="800" height="300"></canvas>
<div id="count">0</div>

<script>
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");
const countEl = document.getElementById("count");

// --- persistent start ---
const KEY = "clockchart_start";
let start = localStorage.getItem(KEY);
if (!start) {
  start = Date.now();
  localStorage.setItem(KEY, start);
} else {
  start = Number(start);
}

// --- config ---
const INTERVAL_SEC = 1;
const CANDLE_WIDTH = 6;
const CANDLE_GAP = 4;
const STEP = CANDLE_WIDTH + CANDLE_GAP;

// --- swipe ---
let scrollOffset = 0;
let isDragging = false;
let lastX = 0;
let trailAlpha = 0;

// --- audio ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playChime(pitch = 440) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.value = pitch;
  g.gain.value = 0.0001;
  g.gain.exponentialRampToValueAtTime(0.04, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.25);
  o.connect(g).connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + 0.26);
}

// --- pointer handlers ---
canvas.addEventListener("pointerdown", e => {
  isDragging = true;
  lastX = e.clientX;
  trailAlpha = 1;
});

canvas.addEventListener("pointermove", e => {
  if (!isDragging) return;
  const dx = e.clientX - lastX;
  scrollOffset += dx;
  lastX = e.clientX;
  playChime(300 + Math.abs(dx) * 4);
  trailAlpha = 1;
});

canvas.addEventListener("pointerup", () => isDragging = false);
canvas.addEventListener("pointerleave", () => isDragging = false);

// --- draw ---
function draw() {
  // fade background
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const elapsedSec = Math.floor((Date.now() - start) / 1000);
  const candles = Math.floor(elapsedSec / INTERVAL_SEC) + 1;
  countEl.textContent = `${candles} seconds`;

  const maxVisible = Math.ceil(canvas.width / STEP) + 2;
  const startIndex = Math.max(0, candles - maxVisible);

  for (let i = startIndex; i < candles; i++) {
    const x = (i - startIndex) * STEP + scrollOffset;
    if (x < -STEP || x > canvas.width + STEP) continue;

    const h = ((i + 1) / candles) * canvas.height;

    // candle color (alternating)
    ctx.fillStyle = (i % 2 === 0) ? "#b084ff" : "#5a2bbf";
    ctx.fillRect(x, canvas.height - h, CANDLE_WIDTH, Math.max(h, 6));

    // ---- number inside candle ----
    const label = String(i + 1);

    // auto font sizing based on digits + candle height
    const maxFont = Math.min(14, h * 0.6);
    const minFont = 6;
    let fontSize = maxFont;

    ctx.save();
    ctx.translate(x + CANDLE_WIDTH / 2, canvas.height - h + 4);
    ctx.rotate(-Math.PI / 2);

    while (fontSize > minFont) {
      ctx.font = `${fontSize}px system-ui`;
      if (ctx.measureText(label).width <= h - 8) break;
      fontSize--;
    }

    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }

  // trail glow
  if (trailAlpha > 0) {
    ctx.fillStyle = `rgba(176,132,255,${trailAlpha * 0.08})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    trailAlpha *= 0.9;
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
