<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ClockChart</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: black;
}
canvas {
  display: block;
  touch-action: none;
}
</style>
</head>
<body>

<canvas id="chart"></canvas>

<script>
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");

// ---------- resize ----------
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ---------- persistent time ----------
const KEY = "clockchart_start";
let start = localStorage.getItem(KEY);
if (!start) {
  start = Date.now();
  localStorage.setItem(KEY, start);
} else {
  start = Number(start);
}

// ---------- chart config ----------
const CHART_WIDTH = 800;
const CHART_HEIGHT = 300;
const INTERVAL_SEC = 1;
const CANDLE_WIDTH = 6;
const CANDLE_GAP = 4;
const STEP = CANDLE_WIDTH + CANDLE_GAP;

// ---------- interaction ----------
let scrollOffset = 0;
let isHolding = false;
let lastX = 0;
let px = 0;
let py = 0;

// ---------- pointer ----------
canvas.addEventListener("pointerdown", e => {
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  isHolding = true;
  lastX = e.clientX;
  px = e.clientX;
  py = e.clientY;
});
canvas.addEventListener("pointermove", e => {
  if (!isHolding) return;
  const dx = e.clientX - lastX;
  scrollOffset += dx;
  lastX = e.clientX;
  px = e.clientX;
  py = e.clientY;
});
canvas.addEventListener("pointerup", e => {
  isHolding = false;
  canvas.releasePointerCapture(e.pointerId);
});
canvas.addEventListener("pointercancel", () => isHolding = false);

// ---------- neon flicker state ----------
let neonPulse = 1;
let flickerTimer = 0;

// ---------- draw loop ----------
function draw() {
  // background decay
  ctx.fillStyle = isHolding
    ? "rgba(0,0,0,0.06)"
    : "rgba(0,0,0,0.22)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  // ---------- DFI TIME NEON ----------
  flickerTimer++;
  if (Math.random() < 0.06) neonPulse = 0.5 + Math.random() * 0.5;
  neonPulse += (1 - neonPulse) * 0.08;

  ctx.save();
  ctx.translate(cx, cy - CHART_HEIGHT / 2 - 60);
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = "bold clamp(48px,10vw,160px) system-ui";

  ctx.shadowColor = "rgba(140,80,255,0.8)";
  ctx.shadowBlur = 40 * neonPulse;

  ctx.fillStyle = `rgba(180,130,255,${0.85 * neonPulse})`;
  ctx.fillText("DFI TIME", 0, 0);

  // outer glow
  ctx.shadowBlur = 90 * neonPulse;
  ctx.fillStyle = `rgba(110,60,200,${0.35 * neonPulse})`;
  ctx.fillText("DFI TIME", 0, 0);

  ctx.restore();

  // ---------- chart origin ----------
  const ox = cx - CHART_WIDTH / 2;
  const oy = cy + 40;

  const elapsedSec = Math.floor((Date.now() - start) / 1000);
  const candles = Math.floor(elapsedSec / INTERVAL_SEC) + 1;

  const maxVisible = Math.ceil(CHART_WIDTH / STEP) + 2;
  const startIndex = Math.max(0, candles - maxVisible);

  // ---------- candles ----------
  for (let i = startIndex; i < candles; i++) {
    const x = ox + (i - startIndex) * STEP + scrollOffset;
    if (x < ox - STEP || x > ox + CHART_WIDTH + STEP) continue;

    const h = ((i + 1) / candles) * CHART_HEIGHT;
    ctx.fillStyle = (i % 2 === 0) ? "#8f6bff" : "#3a1c66";
    ctx.fillRect(x, oy + CHART_HEIGHT - h, CANDLE_WIDTH, Math.max(h, 6));
  }

  // ---------- trail glow (anywhere on screen) ----------
  if (isHolding) {
    ctx.globalCompositeOperation = "lighter";
    const r = 100;
    const g = ctx.createRadialGradient(px, py, 0, px, py, r);
    g.addColorStop(0, "rgba(120,80,200,0.25)");
    g.addColorStop(0.4, "rgba(90,60,150,0.12)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(px - r, py - r, r * 2, r * 2);
    ctx.globalCompositeOperation = "source-over";
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
