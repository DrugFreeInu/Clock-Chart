<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ClockChart</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  background: black;
  font-family: system-ui, sans-serif;
  color: #caa6ff;
}

/* ---- MASSIVE NEON SIGN ---- */
#neon {
  position: absolute;
  top: 6%;
  width: 100%;
  text-align: center;
  pointer-events: none;

  font-weight: 900;
  letter-spacing: 0.18em;

  /* ðŸ”¥ BIG BIG */
  font-size: min(22vw, 260px);

  color: #c59bff;

  text-shadow:
    0 0 10px rgba(197,155,255,0.75),
    0 0 32px rgba(176,132,255,0.75),
    0 0 80px rgba(140,60,255,0.7),
    0 0 160px rgba(100,20,200,0.6);

  animation: breathe 4.5s ease-in-out infinite;
}

/* breathing glow */
@keyframes breathe {
  0% {
    opacity: 0.9;
  }
  50% {
    opacity: 1;
    text-shadow:
      0 0 18px rgba(197,155,255,1),
      0 0 64px rgba(176,132,255,1),
      0 0 140px rgba(140,60,255,0.95),
      0 0 260px rgba(100,20,200,0.9);
  }
  100% {
    opacity: 0.9;
  }
}

canvas {
  display: block;
  touch-action: none;
}
</style>
</head>

<body>

<div id="neon">DFI&nbsp;TIME</div>
<canvas id="chart"></canvas>

<script>
/* ================= NEON FLICKER ================= */
const neon = document.getElementById("neon");

function flicker() {
  const r = Math.random();

  if (r < 0.05) {
    neon.style.opacity = "0.25";
    setTimeout(() => neon.style.opacity = "1", 45);
  }
  else if (r < 0.1) {
    neon.style.textShadow = `
      0 0 12px rgba(197,155,255,0.4),
      0 0 36px rgba(176,132,255,0.45),
      0 0 80px rgba(140,60,255,0.35)
    `;
    setTimeout(resetGlow, 140);
  }
}

function resetGlow() {
  neon.style.textShadow = `
    0 0 10px rgba(197,155,255,0.75),
    0 0 32px rgba(176,132,255,0.75),
    0 0 80px rgba(140,60,255,0.7),
    0 0 160px rgba(100,20,200,0.6)
  `;
}

setInterval(flicker, 220);

/* ================= CLOCKCHART ================= */
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ---- chart layout ----
const CHART_WIDTH = 800;
const CHART_HEIGHT = 300;

// ---- persistent time ----
const KEY = "clockchart_start";
let start = localStorage.getItem(KEY);
if (!start) {
  start = Date.now();
  localStorage.setItem(KEY, start);
} else {
  start = Number(start);
}

// ---- config ----
const INTERVAL_SEC = 1;
const CANDLE_WIDTH = 6;
const CANDLE_GAP = 4;
const STEP = CANDLE_WIDTH + CANDLE_GAP;

// ---- interaction ----
let scrollOffset = 0;
let isHolding = false;
let lastX = 0;
let px = canvas.width / 2;
let py = canvas.height / 2;

function updatePointer(e) {
  px = e.clientX;
  py = e.clientY;
}

canvas.addEventListener("pointerdown", e => {
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  isHolding = true;
  lastX = e.clientX;
  updatePointer(e);
});

canvas.addEventListener("pointermove", e => {
  if (!isHolding) return;
  e.preventDefault();
  scrollOffset += e.clientX - lastX;
  lastX = e.clientX;
  updatePointer(e);
});

canvas.addEventListener("pointerup", e => {
  isHolding = false;
  canvas.releasePointerCapture(e.pointerId);
});

canvas.addEventListener("pointercancel", () => isHolding = false);

// ---- draw loop ----
function draw() {
  ctx.fillStyle = isHolding
    ? "rgba(0,0,0,0.06)"
    : "rgba(0,0,0,0.24)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const ox = (canvas.width - CHART_WIDTH) / 2;
  const oy = (canvas.height - CHART_HEIGHT) / 2 + 120;

  const elapsedSec = Math.floor((Date.now() - start) / 1000);
  const candles = Math.floor(elapsedSec / INTERVAL_SEC) + 1;

  const maxVisible = Math.ceil(CHART_WIDTH / STEP) + 2;
  const startIndex = Math.max(0, candles - maxVisible);

  for (let i = startIndex; i < candles; i++) {
    const x = ox + (i - startIndex) * STEP + scrollOffset;
    if (x < ox - STEP || x > ox + CHART_WIDTH + STEP) continue;

    const h = ((i + 1) / candles) * CHART_HEIGHT;
    ctx.fillStyle = (i % 2 === 0) ? "#9a6bff" : "#4b257a";
    ctx.fillRect(x, oy + CHART_HEIGHT - h, CANDLE_WIDTH, Math.max(h, 6));
  }

  if (isHolding) {
    ctx.globalCompositeOperation = "lighter";
    const r = 90;
    const g = ctx.createRadialGradient(px, py, 0, px, py, r);
    g.addColorStop(0, "rgba(110,70,170,0.22)");
    g.addColorStop(0.4, "rgba(90,55,140,0.12)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(px - r, py - r, r * 2, r * 2);
    ctx.globalCompositeOperation = "source-over";
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
