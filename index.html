<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ClockChart</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  background: black;
  font-family: system-ui, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #caa6ff;
}

canvas {
  border: 1px solid #2a0044;
  touch-action: none;
}

#count {
  margin-top: 8px;
  font-size: 14px;
}
</style>
</head>
<body>

<canvas id="chart" width="800" height="300"></canvas>
<div id="count">0</div>

<script>
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d");
const countEl = document.getElementById("count");

// ---- persistent time ----
const KEY = "clockchart_start";
let start = localStorage.getItem(KEY);
if (!start) {
  start = Date.now();
  localStorage.setItem(KEY, start);
} else {
  start = Number(start);
}

// ---- config ----
const INTERVAL_SEC = 1;
const CANDLE_WIDTH = 6;
const CANDLE_GAP = 4;
const STEP = CANDLE_WIDTH + CANDLE_GAP;

// ---- interaction ----
let scrollOffset = 0;
let isHolding = false;
let lastX = 0;
let px = canvas.width / 2;
let py = canvas.height / 2;

// ---- pointer helpers ----
function updatePointer(e) {
  const rect = canvas.getBoundingClientRect();
  px = e.clientX - rect.left;
  py = e.clientY - rect.top;
}

// ---- pointer events (FIXED) ----
canvas.addEventListener("pointerdown", e => {
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  isHolding = true;
  lastX = e.clientX;
  updatePointer(e);
});

canvas.addEventListener("pointermove", e => {
  if (!isHolding) return;
  e.preventDefault();
  const dx = e.clientX - lastX;
  scrollOffset += dx;
  lastX = e.clientX;
  updatePointer(e);
});

canvas.addEventListener("pointerup", e => {
  isHolding = false;
  canvas.releasePointerCapture(e.pointerId);
});

canvas.addEventListener("pointercancel", () => isHolding = false);

// ---- draw loop ----
function draw() {
  // background decay (slower = stronger trails)
  ctx.fillStyle = isHolding
    ? "rgba(0,0,0,0.04)"
    : "rgba(0,0,0,0.22)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const elapsedSec = Math.floor((Date.now() - start) / 1000);
  const candles = Math.floor(elapsedSec / INTERVAL_SEC) + 1;
  countEl.textContent = `${candles} seconds`;

  const maxVisible = Math.ceil(canvas.width / STEP) + 2;
  const startIndex = Math.max(0, candles - maxVisible);

  // ---- candles ----
  for (let i = startIndex; i < candles; i++) {
    const x = (i - startIndex) * STEP + scrollOffset;
    if (x < -STEP || x > canvas.width + STEP) continue;

    const h = ((i + 1) / candles) * canvas.height;
    ctx.fillStyle = (i % 2 === 0) ? "#b084ff" : "#5a2bbf";
    ctx.fillRect(x, canvas.height - h, CANDLE_WIDTH, Math.max(h, 6));
  }

  // ---- GUARANTEED glow trail ----
  if (isHolding) {
    ctx.globalCompositeOperation = "lighter";

    const r = 90;
    const g = ctx.createRadialGradient(px, py, 0, px, py, r);
    g.addColorStop(0, "rgba(190,150,255,0.55)");
    g.addColorStop(0.5, "rgba(160,120,255,0.25)");
    g.addColorStop(1, "rgba(160,120,255,0)");

    ctx.fillStyle = g;
    ctx.fillRect(px - r, py - r, r * 2, r * 2);

    ctx.globalCompositeOperation = "source-over";
  }

  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
